import React, { useState, useEffect } from "react";
import ReactDOM from "react-dom/client";
import "./index.css"; // Ensure this CSS path is correct

// Import AuthClient from the DFINITY SDK for Internet Identity authentication.
import { AuthClient } from "@dfinity/auth-client";
// Import the backend canister declarations generated by DFX.
// Ensure this path matches your project structure (e.g., 'declarations/your_canister_name').
import { mini_project_backend } from "declarations/mini-project-backend";

// Import chart components from the Recharts library for data visualization.
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  Tooltip,
  ResponsiveContainer,
  CartesianGrid,
} from "recharts";

/**
 * @function MainApp
 * @description The main React component for the DFINITY voting application.
 * Manages user authentication, voting logic, and displays real-time results.
 * @returns {JSX.Element} The rendered application UI.
 */
const MainApp = () => {
  // State variables to manage application data and UI status.
  const [greeting, setGreeting] = useState(""); // Stores the greeting message from the backend.
  const [authClient, setAuthClient] = useState(null); // Instance of the DFINITY AuthClient.
  const [identity, setIdentity] = useState(null); // The authenticated user's identity object.
  const [principal, setPrincipal] = useState(null); // The authenticated user's Principal ID as a string.
  const [hasVoted, setHasVoted] = useState(false); // Boolean indicating if the current user has voted.
  const [results, setResults] = useState({
    // Object storing vote counts for each language.
    rust: 0,
    assemblyScript: 0,
    motoko: 0,
  });
  const [totalVotes, setTotalVotes] = useState(0); // Total number of votes cast across all languages.
  const [status, setStatus] = useState(""); // User-facing status messages (e.g., success, error).

  /**
   * @useEffect
   * @description Initializes the AuthClient when the component mounts.
   * Checks if a user is already authenticated from a previous session and loads their data.
   * This effect runs only once after the initial render (due to empty dependency array).
   */
  useEffect(() => {
    AuthClient.create()
      .then(async (client) => {
        setAuthClient(client);
        console.log("[INIT] AuthClient successfully created.");
        // Check if the user is already authenticated.
        if (client.isAuthenticated()) {
          console.log("[INIT] Client is authenticated. Loading user data...");
          await loadUser(client); // Load user-specific data if authenticated.
        } else {
          console.log("[INIT] Client is not authenticated.");
        }
      })
      .catch((error) => {
        console.error("[ERROR] Failed to create AuthClient:", error);
        setStatus("Failed to initialize application. Check browser console.");
      });
  }, []); // Empty dependency array ensures this runs only once on mount.

  /**
   * @function loadUser
   * @description Loads user-specific data (greeting, voting status, results, total votes) from the backend.
   * This function is called after successful login or if a user is already authenticated.
   * @param {AuthClient} client The DFINITY AuthClient instance.
   * @async
   */
  const loadUser = async (client) => {
    // Get the current authenticated identity and its Principal ID.
    const currentIdentity = client.getIdentity();
    const principalText = currentIdentity.getPrincipal().toText();
    setIdentity(currentIdentity);
    setPrincipal(principalText);
    setStatus("Loading user data and voting results...");
    console.log(`[LOAD USER] Active Principal: ${principalText}`);

    try {
      // Fetch the greeting message from the backend.
      const message = await mini_project_backend.greet();
      setGreeting(message);
      console.log(`[LOAD USER] Greeting from backend: "${message}"`);

      // Check if the current Principal has already voted.
      const votedStatus = await mini_project_backend.hasVoted();
      console.log(
        `[LOAD USER] 'hasVoted' status for ${principalText}: ${votedStatus}`
      );
      setHasVoted(votedStatus);

      // Fetch the current voting results for all languages.
      const currentResults = await mini_project_backend.getResults();
      console.log(
        "[LOAD USER] Raw voting results from backend:",
        currentResults
      );
      // Convert BigInt values (from Motoko Nat) to JavaScript Numbers for React state.
      setResults({
        rust: Number(currentResults.rust),
        assemblyScript: Number(currentResults.assemblyScript),
        motoko: Number(currentResults.motoko),
      });

      // Fetch the total number of votes.
      const total = await mini_project_backend.totalVotes();
      console.log(
        `[LOAD USER] Raw total votes from backend: ${total}, Type: ${typeof total}`
      );
      // Convert BigInt to Number.
      setTotalVotes(Number(total));
      console.log(`[LOAD USER] Total votes after conversion: ${Number(total)}`);

      setStatus("Data loaded successfully.");
    } catch (error) {
      console.error(
        "[ERROR] Failed to load user data or voting results:",
        error
      );
      setStatus("Failed to load data. Check browser console for details.");
      // Reset relevant states on error to prevent displaying stale/incorrect data.
      setHasVoted(false);
      setResults({ rust: 0, assemblyScript: 0, motoko: 0 });
      setTotalVotes(0);
    }
  };

  /**
   * @function handleLogin
   * @description Initiates the Internet Identity login process.
   * Redirects the user to the Internet Identity provider for authentication.
   * @async
   */
  const handleLogin = async () => {
    setStatus("Redirecting to Internet Identity for login...");
    try {
      await authClient.login({
        identityProvider: "https://identity.ic0.app/#authorize", // Internet Identity provider URL.
        onSuccess: async () => {
          console.log(
            "[LOGIN] Successfully logged in. Loading new user data..."
          );
          await loadUser(authClient); // Load user data upon successful login.
        },
        onError: (error) => {
          console.error("[ERROR] Login failed:", error);
          setStatus(`Login failed: ${error.message || "Unknown error"}`);
        },
      });
    } catch (error) {
      console.error(
        "[ERROR] An issue occurred while starting the login process:",
        error
      );
      setStatus("An error occurred during login initiation.");
    }
  };

  /**
   * @function handleLogout
   * @description Handles the user logout process.
   * Resets all relevant state variables to their initial values.
   * @async
   */
  const handleLogout = async () => {
    setStatus("Logging out...");
    try {
      await authClient.logout();
      // Reset all user-related state variables after logout.
      setIdentity(null);
      setPrincipal(null);
      setGreeting("");
      setHasVoted(false);
      setResults({ rust: 0, assemblyScript: 0, motoko: 0 });
      setTotalVotes(0);
      setStatus("Successfully logged out.");
      console.log("[LOGOUT] User logged out. State reset.");
    } catch (error) {
      console.error("[ERROR] Failed to logout:", error);
      setStatus("Failed to logout. Check browser console.");
    }
  };

  /**
   * @function handleVote
   * @description Handles the user's vote submission.
   * Validates the user's login status and voting eligibility before sending the vote to the backend.
   * @param {string} lang The language string ("rust", "assemblyScript", or "motoko") to vote for.
   * @async
   */
  const handleVote = async (lang) => {
    // Prevent voting if not logged in or if using the anonymous principal.
    if (!identity || principal === "2vxsx-fae") {
      setStatus("❌ Please log in first to vote.");
      console.warn(
        "[VOTE] Attempted vote without login or with anonymous principal."
      );
      return;
    }

    // Prevent voting if the user has already voted (based on frontend state).
    if (hasVoted) {
      setStatus("❌ You have already voted. One vote per account.");
      console.warn(`[VOTE] Principal ${principal} has already voted.`);
      return;
    }

    // Determine the correct language variant object to send to the backend.
    let langVariant;
    switch (lang) {
      case "rust":
        langVariant = { rust: null };
        break;
      case "assemblyScript":
        langVariant = { assemblyScript: null };
        break;
      case "motoko":
        langVariant = { motoko: null };
        break;
      default:
        setStatus("❌ Invalid language selected.");
        console.error("[VOTE] Invalid language selected for voting.");
        return;
    }

    setStatus(`Submitting vote for ${lang}...`);
    try {
      // Call the 'vote' function on the backend canister.
      const success = await mini_project_backend.vote(langVariant);
      console.log(
        `[VOTE] Result from mini_project_backend.vote(${lang}): ${success}`
      );

      if (success) {
        setStatus("✅ Vote submitted successfully!");
        setHasVoted(true); // Immediately update frontend state to reflect vote.

        // Reload updated results and total votes from the backend.
        const updatedResults = await mini_project_backend.getResults();
        console.log("[VOTE] Latest results after vote:", updatedResults);
        setResults({
          rust: Number(updatedResults.rust),
          assemblyScript: Number(updatedResults.assemblyScript),
          motoko: Number(updatedResults.motoko),
        });

        const total = await mini_project_backend.totalVotes();
        console.log(
          `[VOTE] Latest raw total votes: ${total}, Type: ${typeof total}`
        );
        setTotalVotes(Number(total));
        console.log(
          `[VOTE] Latest total votes after conversion: ${Number(total)}`
        );
      } else {
        // If the backend returns false (e.g., due to duplicate vote attempt).
        setStatus(
          "❌ Voting failed. You might have already voted, or there's a backend issue."
        );
        console.warn("[VOTE] Backend indicated vote failed (returned false).");
      }
    } catch (err) {
      // Catch any unexpected errors during the voting process (e.g., network issues).
      console.error("[ERROR] An unexpected error occurred during voting:", err);
      setStatus(
        "❌ An unexpected error occurred during voting. Check browser console."
      );
    }
  };

  // Prepare data in the format required by Recharts for the BarChart.
  const chartData = [
    { name: "Rust", votes: results.rust },
    { name: "AssemblyScript", votes: results.assemblyScript },
    { name: "Motoko", votes: results.motoko },
  ];

  return (
    <div className="container">
      {/* ICP Logo displayed at the top of the container */}
      <img src="/logo2.svg" alt="Internet Computer Logo" className="logo" />

      {/* Conditional rendering: Show different UI based on user's login status */}
      {principal ? (
        <>
          {/* Display user's Principal ID */}
          <p>
            👤 Your Principal ID: <code>{principal}</code>
          </p>
          {/* Display greeting message from the backend */}
          <h2>{greeting}</h2>

          {/* Conditional rendering: Show voting options if user hasn't voted */}
          {!hasVoted ? (
            <>
              <h3>🗳️ Vote for Your Favorite Programming Language:</h3>
              <div className="button-group">
                {" "}
                {/* Group for styling vote buttons */}
                <button className="button" onClick={() => handleVote("rust")}>
                  Rust
                </button>
                <button
                  className="button"
                  onClick={() => handleVote("assemblyScript")}
                >
                  AssemblyScript
                </button>
                <button className="button" onClick={() => handleVote("motoko")}>
                  Motoko
                </button>
              </div>
            </>
          ) : (
            // Display message if user has already voted
            <p>✅ Thank you for voting! You can only vote once.</p>
          )}

          {/* Display application status messages */}
          <p className="status-message">{status}</p>

          {/* Display current voting results */}
          <h3>📊 Current Voting Results</h3>
          <ul>
            <li>Rust: {results.rust} votes</li>
            <li>AssemblyScript: {results.assemblyScript} votes</li>
            <li>Motoko: {results.motoko} votes</li>
          </ul>
          <p>Total Votes: {totalVotes}</p>

          {/* Container for the Recharts BarChart */}
          <div className="chart-container">
            <ResponsiveContainer width="100%" height={300}>
              <BarChart data={chartData}>
                <CartesianGrid strokeDasharray="3 3" />{" "}
                {/* Grid lines for the chart */}
                <XAxis dataKey="name" /> {/* X-axis labels (language names) */}
                <YAxis allowDecimals={false} />{" "}
                {/* Y-axis for vote counts, ensuring whole numbers */}
                <Tooltip /> {/* Tooltip on hover to show exact vote count */}
                <Bar dataKey="votes" fill="#6366f1" />{" "}
                {/* Bar representation of votes with a solid color */}
              </BarChart>
            </ResponsiveContainer>
          </div>

          {/* Logout button */}
          <button className="button logout-button" onClick={handleLogout}>
            Logout
          </button>
        </>
      ) : (
        // Display login button if user is not authenticated
        <button className="button" onClick={handleLogin}>
          Login with Internet Identity
        </button>
      )}
    </div>
  );
};

// Render the MainApp component into the DOM.
ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <MainApp />
  </React.StrictMode>
);
